/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdlib.h>

#include "../Inc/MCAL/RCC/RCC_interface.h"
#include "../Inc/MCAL/GPIO/GPIO_interface.h"
#include "../Inc/MCAL/SPI/SPI_interfce.h"
#include "../inc/MCAL/STK/STK_interface.h"
#include "../Inc/HAL/TFT/TFT_interface.h"
#include "../Inc/MCAL/ADC/ADC_Interface.h"
#include "../Inc/SERVICE/RTOS/RTOS_interface.h"



u16 result;
s8 temp[16];

/*Task to update the ADC read*/
void Task_ReadADC (void)
{
MADC_voidReadResultBlocking(ADC1, CHANNEL0, _1_CONVERSION, &result);
}

/**/
void If_Temp_less100_Task (void)
{
	 if (result < 50)
	 {
		 HTFT_voidFillDisplay(TFT_BLUE);
		 HTFT_voidPrintText((s8 *)"Temp Value :" , 30 , 70 , 1 , TFT_BLACK , TFT_BLUE );
		 itoa(result, temp, 10);
		HTFT_voidPrintText(temp , 105 , 70 , 1 , TFT_BLACK , TFT_BLUE );
		MGPIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN1, GPIO_LOW);

	}
	 else
	 {
	 }
}

void If_Temp_more100_Task (void)
{
	if (result >= 50)
	{
		     HTFT_voidFillDisplay(TFT_RED);
		     HTFT_voidPrintText((s8 *)"Temp Value :" , 20 , 20 , 1 , TFT_BLACK , TFT_RED );
		     itoa(result, temp, 10);
		     HTFT_voidPrintText(temp , 105 , 20 , 1 , TFT_BLACK , TFT_RED );
		     HTFT_voidPrintText((s8*)"WARNNING" , 20 , 70 , 2 , TFT_BLACK , TFT_RED );
		     MGPIO_voidSetPinValue(GPIO_U8_PORTB, GPIO_U8_PIN1, GPIO_HIGH);
	}
	else
	{
	}
}
int main(void)
{
		/*RCC init*/
    	MRCC_voidInit();

    	/*systm tick init*/
    	MSTK_voidInit();

	    /* Enable the clock for all ports */
		MRCC_voidPreipheralEnable(APB2 , IOPA_ENABLE_BIT);
		MRCC_voidPreipheralEnable(APB2 , IOPB_ENABLE_BIT);

		MRCC_voidPreipheralEnable(APB2 , SPI1_ENABLE_BIT);
		MRCC_voidPreipheralEnable(APB2 , ADC1_ENABLE_BIT);

		/*init ADC */
		MADC_voidInit();
		/*ADC channel 0 pin*/
		MGPIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN0, GPIO_INPUT_FLOATING);

		/*Buzzer pin config*/
		MGPIO_voidSetPinDirection(GPIO_U8_PORTB, GPIO_U8_PIN1, GPIO_OUTPUT_PP_10MHZ);

		/* Configure pins for SPI */
		MGPIO_voidSetPinDirection(GPIO_U8_PORTA , GPIO_U8_PIN7 , GPIO_OUTPUT_AF_PP_10MHZ); //MOSI
		MGPIO_voidSetPinDirection(GPIO_U8_PORTA , GPIO_U8_PIN6 , GPIO_INPUT_FLOATING); //MISO
		MGPIO_voidSetPinDirection(GPIO_U8_PORTA , GPIO_U8_PIN5 , GPIO_OUTPUT_AF_PP_10MHZ); //SCK



		/* Configure pins for TFT */
		MGPIO_voidSetPinDirection( GPIO_U8_PORTA, GPIO_U8_PIN1 , GPIO_OUTPUT_PP_10MHZ); /*RST*/
		MGPIO_voidSetPinDirection(GPIO_U8_PORTA, GPIO_U8_PIN2 , GPIO_OUTPUT_PP_10MHZ); /*A0*/


	   /* master - idle high - write first - msb - 8bit format - sw m slave ,full duplex ,
		f/2 / disable ISR*/
		SPI_config_t SPI1_config = { 1 , 1 , 1 , 0 , 0 , 1, 0 ,0 ,0 };

		/*init SPI */
		SPI_u8ConfigureCh(SPI1 , &SPI1_config );

		/* Initialize TFT */
		HTFT_voidInit();


		HTFT_voidFillDisplay(TFT_ORANGE );
	    HTFT_voidPrintText((s8*)"HELLO" , 40 , 70 , 2 , TFT_BLACK , TFT_ORANGE );
	    MSTK_voidSetBusyWait(5000);

	    /*Create Tasks*/
	    SRTOS_voidCreatTask(0, 100 , Task_ReadADC, 0);
	    SRTOS_voidCreatTask(1, 500 , If_Temp_less100_Task, 100);
	    SRTOS_voidCreatTask(2, 700 , If_Temp_more100_Task, 200);

	    /*start OS*/
	    SRTOS_voidInit();

	for(;;)
	{

	}
}
